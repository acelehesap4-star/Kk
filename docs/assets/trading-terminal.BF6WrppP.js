var N=Object.defineProperty;var B=(a,e,t)=>e in a?N(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var p=(a,e,t)=>B(a,typeof e!="symbol"?e+"":e,t);import{r as f}from"./vendor-core.BARHdY6Y.js";import"./vendor-features.6ISre1Wy.js";import"./trading-core.Bat-HQlx.js";class l{constructor(e){p(this,"config");p(this,"sandboxMode",!1);this.config=e,console.warn("CCXT cannot run in browser environment. Please implement a backend service to proxy exchange API calls. See documentation: https://docs.ccxt.com/en/latest/manual.html#proxy")}setSandboxMode(e){this.sandboxMode=e}throwNotImplemented(e){throw new Error(`${e} is not available in browser mode. Implement a backend service to handle exchange operations.`)}async fetchBalance(){this.throwNotImplemented("fetchBalance")}async createOrder(e,t,r,n,s){this.throwNotImplemented("createOrder")}async cancelOrder(e,t){this.throwNotImplemented("cancelOrder")}async fetchOrders(e){this.throwNotImplemented("fetchOrders")}async fetchOpenOrders(e){this.throwNotImplemented("fetchOpenOrders")}async fetchTicker(e){this.throwNotImplemented("fetchTicker")}async fetchOHLCV(e,t,r,n){this.throwNotImplemented("fetchOHLCV")}async withdraw(e,t,r,n){this.throwNotImplemented("withdraw")}async fetchDeposits(e){this.throwNotImplemented("fetchDeposits")}async fetchWithdrawals(e){this.throwNotImplemented("fetchWithdrawals")}async fetchDepositAddress(e){this.throwNotImplemented("fetchDepositAddress")}}const A={binance:l,coinbasepro:l,okx:l,kucoin:l,kraken:l,bybit:l,bitfinex:l},I={BINANCE:{id:"BINANCE",name:"Binance",type:"crypto",ccxtId:"binance",requiresCredentials:!0,isActive:!0,supportedFeatures:{spot:!0,margin:!0,futures:!0,options:!0,swap:!0}},COINBASE:{id:"COINBASE",name:"Coinbase Pro",type:"crypto",ccxtId:"coinbasepro",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!1,futures:!1,options:!1,swap:!1}},OKX:{id:"OKX",name:"OKX",type:"crypto",ccxtId:"okx",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!0,futures:!0,options:!0,swap:!0}},KUCOIN:{id:"KUCOIN",name:"KuCoin",type:"crypto",ccxtId:"kucoin",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!0,futures:!0,options:!1,swap:!1}},KRAKEN:{id:"KRAKEN",name:"Kraken",type:"crypto",ccxtId:"kraken",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!0,futures:!0,options:!1,swap:!1}},BYBIT:{id:"BYBIT",name:"Bybit",type:"crypto",ccxtId:"bybit",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!1,futures:!0,options:!0,swap:!0}},BITFINEX:{id:"BITFINEX",name:"Bitfinex",type:"crypto",ccxtId:"bitfinex",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!0,futures:!1,options:!1,swap:!1}},NASDAQ:{id:"NASDAQ",name:"NASDAQ",type:"stock",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!0,futures:!1,options:!0,swap:!1}},NYSE:{id:"NYSE",name:"New York Stock Exchange",type:"stock",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!0,futures:!1,options:!0,swap:!1}},FOREX:{id:"FOREX",name:"Forex Market",type:"forex",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!0,futures:!1,options:!1,swap:!0}},CME:{id:"CME",name:"Chicago Mercantile Exchange",type:"commodity",requiresCredentials:!0,supportedFeatures:{spot:!1,margin:!1,futures:!0,options:!0,swap:!1}}};class k{constructor(){p(this,"exchanges",new Map)}createExchange(e,t,r,n=!0){const s=I[e];if(!s||!s.ccxtId)throw new Error(`Exchange ${e} not supported for real trading`);const o=A[s.ccxtId];if(!o)throw new Error(`CCXT exchange ${s.ccxtId} not found`);const c=new o({apiKey:t,secret:r,enableRateLimit:!0,options:{defaultType:"spot",adjustForTimeDifference:!0}});return n&&c.setSandboxMode(!0),this.exchanges.set(e,c),c}getExchange(e){return this.exchanges.get(e)}async fetchBalance(e){const t=this.getExchange(e);if(!t)throw new Error(`Exchange ${e} not connected`);return await t.fetchBalance()}async createOrder(e,t,r,n,s,o){const c=this.getExchange(e);if(!c)throw new Error(`Exchange ${e} not connected`);return await c.createOrder(t,r,n,s,o)}async cancelOrder(e,t,r){const n=this.getExchange(e);if(!n)throw new Error(`Exchange ${e} not connected`);return await n.cancelOrder(t,r)}async fetchOrders(e,t){const r=this.getExchange(e);if(!r)throw new Error(`Exchange ${e} not connected`);return await r.fetchOrders(t)}async fetchOpenOrders(e,t){const r=this.getExchange(e);if(!r)throw new Error(`Exchange ${e} not connected`);return await r.fetchOpenOrders(t)}async fetchTicker(e,t){const r=this.getExchange(e);if(!r)throw new Error(`Exchange ${e} not connected`);return await r.fetchTicker(t)}async fetchOHLCV(e,t,r,n=100){const s=this.getExchange(e);if(!s)throw new Error(`Exchange ${e} not connected`);return await s.fetchOHLCV(t,r,void 0,n)}async withdraw(e,t,r,n,s){const o=this.getExchange(e);if(!o)throw new Error(`Exchange ${e} not connected`);return await o.withdraw(t,r,n,s)}async fetchDeposits(e,t){const r=this.getExchange(e);if(!r)throw new Error(`Exchange ${e} not connected`);return await r.fetchDeposits(t)}async fetchWithdrawals(e,t){const r=this.getExchange(e);if(!r)throw new Error(`Exchange ${e} not connected`);return await r.fetchWithdrawals(t)}async fetchDepositAddress(e,t){const r=this.getExchange(e);if(!r)throw new Error(`Exchange ${e} not connected`);return await r.fetchDepositAddress(t)}disconnectExchange(e){this.exchanges.delete(e)}disconnectAll(){this.exchanges.clear()}}const C=new k,M=a=>{const[e,t]=f.useState({total:0,available:0,locked:0,omni99:0,assets:{}}),[r,n]=f.useState(!0),[s,o]=f.useState(null),c=async()=>{try{n(!0),o(null);const i=await C.getConnectedExchanges(a);let E=0,x=0,y=0;const u={};for(const b of i)try{const d=await C.getBalance(b.name,a);Object.entries(d).forEach(([h,g])=>{if(typeof g=="object"&&g!==null){const m=g;u[h]||(u[h]={free:0,used:0,total:0}),u[h].free+=m.free||0,u[h].used+=m.used||0,u[h].total+=m.total||0}});const w=await D(d);E+=w.total,x+=w.available,y+=w.locked}catch(d){console.error(`Error fetching balance from ${b.name}:`,d)}const O=await F(a);t({total:E,available:x,locked:y,omni99:O,assets:u})}catch(i){o(i instanceof Error?i.message:"Failed to fetch balance")}finally{n(!1)}};return f.useEffect(()=>{if(a){c();const i=setInterval(c,3e4);return()=>clearInterval(i)}},[a]),{balance:e,loading:r,error:s,refetch:c}};async function D(a){const e={BTC:67e3,ETH:3400,USDT:1,USDC:1,BNB:600,SOL:160,ADA:.5,DOT:7,MATIC:.8,AVAX:35};let t=0,r=0,n=0;return Object.entries(a).forEach(([s,o])=>{if(typeof o=="object"&&o!==null){const c=o,i=e[s.toUpperCase()]||0;t+=(c.total||0)*i,r+=(c.free||0)*i,n+=(c.used||0)*i}}),{total:t,available:r,locked:n}}async function F(a){try{return 0}catch(e){return console.error("Error fetching OMNI99 balance:",e),0}}export{C as r,M as u};
