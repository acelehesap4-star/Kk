var u=Object.defineProperty;var d=(a,e,t)=>e in a?u(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var h=(a,e,t)=>d(a,typeof e!="symbol"?e+"":e,t);import"./vendor-features.1762518536028.BD6GQA62.js";import"./vendor-core.1762518536028.BKSqPkvP.js";import"./trading-core.1762518536028.CENqH-mq.js";class c{constructor(e){h(this,"config");h(this,"sandboxMode",!1);this.config=e,console.warn("CCXT cannot run in browser environment. Please implement a backend service to proxy exchange API calls. See documentation: https://docs.ccxt.com/en/latest/manual.html#proxy")}setSandboxMode(e){this.sandboxMode=e}throwNotImplemented(e){throw new Error(`${e} is not available in browser mode. Implement a backend service to handle exchange operations.`)}async fetchBalance(){this.throwNotImplemented("fetchBalance")}async createOrder(e,t,r,n,s){this.throwNotImplemented("createOrder")}async cancelOrder(e,t){this.throwNotImplemented("cancelOrder")}async fetchOrders(e){this.throwNotImplemented("fetchOrders")}async fetchOpenOrders(e){this.throwNotImplemented("fetchOpenOrders")}async fetchTicker(e){this.throwNotImplemented("fetchTicker")}async fetchOHLCV(e,t,r,n){this.throwNotImplemented("fetchOHLCV")}async withdraw(e,t,r,n){this.throwNotImplemented("withdraw")}async fetchDeposits(e){this.throwNotImplemented("fetchDeposits")}async fetchWithdrawals(e){this.throwNotImplemented("fetchWithdrawals")}async fetchDepositAddress(e){this.throwNotImplemented("fetchDepositAddress")}}const p={binance:c,coinbasepro:c,okx:c,kucoin:c,kraken:c,bybit:c,bitfinex:c},f={BINANCE:{id:"BINANCE",name:"Binance",type:"crypto",ccxtId:"binance",requiresCredentials:!0,isActive:!0,supportedFeatures:{spot:!0,margin:!0,futures:!0,options:!0,swap:!0}},COINBASE:{id:"COINBASE",name:"Coinbase Pro",type:"crypto",ccxtId:"coinbasepro",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!1,futures:!1,options:!1,swap:!1}},OKX:{id:"OKX",name:"OKX",type:"crypto",ccxtId:"okx",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!0,futures:!0,options:!0,swap:!0}},KUCOIN:{id:"KUCOIN",name:"KuCoin",type:"crypto",ccxtId:"kucoin",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!0,futures:!0,options:!1,swap:!1}},KRAKEN:{id:"KRAKEN",name:"Kraken",type:"crypto",ccxtId:"kraken",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!0,futures:!0,options:!1,swap:!1}},BYBIT:{id:"BYBIT",name:"Bybit",type:"crypto",ccxtId:"bybit",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!1,futures:!0,options:!0,swap:!0}},BITFINEX:{id:"BITFINEX",name:"Bitfinex",type:"crypto",ccxtId:"bitfinex",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!0,futures:!1,options:!1,swap:!1}},NASDAQ:{id:"NASDAQ",name:"NASDAQ",type:"stock",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!0,futures:!1,options:!0,swap:!1}},NYSE:{id:"NYSE",name:"New York Stock Exchange",type:"stock",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!0,futures:!1,options:!0,swap:!1}},FOREX:{id:"FOREX",name:"Forex Market",type:"forex",requiresCredentials:!0,supportedFeatures:{spot:!0,margin:!0,futures:!1,options:!1,swap:!0}},CME:{id:"CME",name:"Chicago Mercantile Exchange",type:"commodity",requiresCredentials:!0,supportedFeatures:{spot:!1,margin:!1,futures:!0,options:!0,swap:!1}}};class l{constructor(){h(this,"exchanges",new Map)}createExchange(e,t,r,n=!0){const s=f[e];if(!s||!s.ccxtId)throw new Error(`Exchange ${e} not supported for real trading`);const o=p[s.ccxtId];if(!o)throw new Error(`CCXT exchange ${s.ccxtId} not found`);const i=new o({apiKey:t,secret:r,enableRateLimit:!0,options:{defaultType:"spot",adjustForTimeDifference:!0}});return n&&i.setSandboxMode(!0),this.exchanges.set(e,i),i}getExchange(e){return this.exchanges.get(e)}async fetchBalance(e){const t=this.getExchange(e);if(!t)throw new Error(`Exchange ${e} not connected`);return await t.fetchBalance()}async createOrder(e,t,r,n,s,o){const i=this.getExchange(e);if(!i)throw new Error(`Exchange ${e} not connected`);return await i.createOrder(t,r,n,s,o)}async cancelOrder(e,t,r){const n=this.getExchange(e);if(!n)throw new Error(`Exchange ${e} not connected`);return await n.cancelOrder(t,r)}async fetchOrders(e,t){const r=this.getExchange(e);if(!r)throw new Error(`Exchange ${e} not connected`);return await r.fetchOrders(t)}async fetchOpenOrders(e,t){const r=this.getExchange(e);if(!r)throw new Error(`Exchange ${e} not connected`);return await r.fetchOpenOrders(t)}async fetchTicker(e,t){const r=this.getExchange(e);if(!r)throw new Error(`Exchange ${e} not connected`);return await r.fetchTicker(t)}async fetchOHLCV(e,t,r,n=100){const s=this.getExchange(e);if(!s)throw new Error(`Exchange ${e} not connected`);return await s.fetchOHLCV(t,r,void 0,n)}async withdraw(e,t,r,n,s){const o=this.getExchange(e);if(!o)throw new Error(`Exchange ${e} not connected`);return await o.withdraw(t,r,n,s)}async fetchDeposits(e,t){const r=this.getExchange(e);if(!r)throw new Error(`Exchange ${e} not connected`);return await r.fetchDeposits(t)}async fetchWithdrawals(e,t){const r=this.getExchange(e);if(!r)throw new Error(`Exchange ${e} not connected`);return await r.fetchWithdrawals(t)}async fetchDepositAddress(e,t){const r=this.getExchange(e);if(!r)throw new Error(`Exchange ${e} not connected`);return await r.fetchDepositAddress(t)}disconnectExchange(e){this.exchanges.delete(e)}disconnectAll(){this.exchanges.clear()}}const E=new l;export{E as r};
